// The header file that includes the socket basic functions for socket communication
// in unix type environment
#include<stdio.h>
// The header file to include the basic c functions like scanf printf etc

#include<stdlib.h>
# define MAXLINE 1024
// MAXLINE to be used in the program to specify the maximum output for the buffer

#include <string.h>
// to use the bzero function

#include<unistd.h>
// to use the read and write function

#include<arpa/inet.h>

// header file to include the power function
#include"diffie.h"

// declaration for the error function that will lead to the
// exit of the program
void error(char* ch);

int 
main(int argc, char *argv[]) {

	// variables declared that will be used in the program
	int sockfd, new_sockfd, port_no, clilen;
	
	// declaring a buffer to hold the temporary data
	char buffer[MAXLINE];
	
	// socket structure for holding the various information
	struct sockaddr_in serv_addr, cli_addr;

	// a variable to indicate the error during the transmission
	int n;
	
	// taking the input of the prime numbers  their primitive root
	// and the secret key in 
	int PKP, PKG, mySecretKey;

	printf("\n\n\t\t\t\t SERVER \n\n");
	
	printf("Please enter the Prime number, their primitive root and your secret key in order \n");
	/* The other way of taking input
	char ch[11];
	char *ptr;
	fgets(ch, 11, stdin); P = strtol(ch, &ptr, 10);
	fgets(ch, 11, stdin); G = strtol(ch, &ptr, 10);
	fgets(ch, 11, stdin); secretKey = strtol(ch, &ptr, 10);*/

	// taking the input of needed for the program
	scanf("%d",&PKP);
	scanf("%d",&PKG);
	scanf("%d", &mySecretKey);

	// Key is generated for the transfer with the help of the private key
	long long int keyGen = power(PKG, mySecretKey, PKP);
	printf("\nWaiting for key by the client \n");
	fflush(stdout);

	if (argc < 2) {
		// the program of server is run from the terminal by
		// giving the port number like this 
		// ./server.c 4566
		// $(pgm_name) (port_no)
		fprintf(stderr, "Error, no port provided\n");
		exit(1);
	}

	// creating a tcp socket for the connection
	sockfd = socket(AF_INET, SOCK_STREAM, 0);

	if(sockfd < 0) {
		// if the return type of the socket 
		// function is less than zero it means
		// socket has not been created due to 
		// anonomous reason, so exit
		error("Error opening socket");
	}

	// clearing the socket structure
	bzero(&serv_addr, sizeof(serv_addr));
	
	// converting the port number received from
	// the commmand line 
	port_no = atoi(argv[1]);

	// filling the socket structure 
	serv_addr.sin_family = AF_INET;	
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(port_no);
	
	if(bind(sockfd, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) < 0){
		// binding the socket structure with the port
		error("ERROR ON BINDING");
	}

	// the socket start listening with the help of the listen function with 
	// the backlog property
	listen(sockfd, 5);

	clilen = sizeof(serv_addr);
		
	// new file descriptor has been created to perform the operation on that 
	// file descriptor with the help of the accept function
	new_sockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);

	if(new_sockfd < 0 ) {
		// error on the accept function
		error("ERROR on accept");
	}

	// clearing the buffer to receive the input
	bzero(buffer, sizeof(buffer));
	
	int converted_no1 = htonl(PKP);
	int converted_no2 = htonl(PKG);
	int converted_no3 = htonl(keyGen);

	int received = 0;

	// sending the prime number to the client
	n = write(new_sockfd, &converted_no1, sizeof(converted_no1));
	if(n < 0)error("Error on reading from socket");

	// sending the primitive root to the client
	n = write(new_sockfd, &converted_no2, sizeof(converted_no2));
	if(n < 0)error("Error on reading from socket");

	// sending the key generated by my private key
	n = write(new_sockfd, &converted_no3, sizeof(converted_no3));
	if(n < 0)error("Error on reading from socket");
	
	n = read(new_sockfd, &received, sizeof(received));

	// calculation of the shared key
	int k = ntohl(received);
	long long int sharedKey = power(k, mySecretKey, PKP);

	// printing the various keys and shared keys during the process
	printf("Public Key used in the process (Prime Number) : %d\n", PKP);
	printf("Public Key used in the process (Primitive Root): %d\n", PKG);
	printf("Public Key sent by me (Server) in the process : %d\n\n", keyGen);
	printf("Shared Key with the client in the process : %d\n", sharedKey);
	
	return 0;

}	
	

void error(char *ch) {	
	
	// error function to handle the error during the 
	// execution
	perror(ch);
	exit(1);

}

